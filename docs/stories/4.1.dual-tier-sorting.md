# Story 4.1: Dual-Tier Sorting Algorithm

## Status
Draft

## Story
**As a** user viewing the dashboard,
**I want** tasks sorted with proper dual-tier pin hierarchy,
**so that** global pins appear first, followed by personal pins, then regular tasks.

## Acceptance Criteria

1. Global pins appear at the top, sorted by priority then date
2. Personal pins appear second, sorted by date pinned
3. Regular tasks follow existing sort logic
4. Filtering respects pin hierarchy (pins visible only if they pass filters)
5. Sorting within each tier maintains existing sort preferences
6. Performance remains optimal with large task lists

## Tasks / Subtasks

- [ ] Pin-Aware Sorting Algorithm (AC: 1, 2, 3)
  - [ ] Implement hierarchical sorting function
  - [ ] Create pin type priority logic
  - [ ] Maintain existing sort preferences within tiers
  - [ ] Handle mixed pin states (task with both pin types)

- [ ] Dashboard Integration (AC: 4, 5)
  - [ ] Update Dashboard component sorting logic
  - [ ] Integrate with existing filter system
  - [ ] Preserve user sort preferences
  - [ ] Handle edge cases (no pins, all pinned, etc.)

- [ ] Kanban Board Support (AC: 1, 2, 3)
  - [ ] Apply dual-tier sorting within Kanban columns
  - [ ] Maintain drag-drop functionality
  - [ ] Handle pin state changes in Kanban view
  - [ ] Ensure visual consistency across views

- [ ] Performance Optimization (AC: 6)
  - [ ] Optimize sorting algorithm for large datasets
  - [ ] Implement memoization for sort results
  - [ ] Add performance monitoring
  - [ ] Handle real-time updates efficiently

- [ ] Sort State Management (AC: 5)
  - [ ] Preserve user sort preferences
  - [ ] Handle sort state with pin hierarchy
  - [ ] Add sort direction support within tiers
  - [ ] Implement sort state persistence

## Dev Notes

### Relevant Source Tree
- `src/components/Dashboard.tsx` - Main dashboard with task list
- `src/components/KanbanBoard.tsx` - Kanban view implementation
- `src/utils/taskSorting.ts` - Sorting utility functions
- `src/hooks/useTaskSorting.ts` - Sort state management

### Hierarchical Sorting Algorithm
```typescript
interface SortedTaskGroups {
  globalPins: Task[];
  personalPins: Task[];
  regular: Task[];
}

export const sortTasksWithPinHierarchy = (
  tasks: Task[],
  globalPins: GlobalPin[],
  personalPins: string[],
  sortConfig: SortConfig
): Task[] => {
  // 1. Separate tasks by pin type
  const groups = categorizeTasksByPinType(tasks, globalPins, personalPins);

  // 2. Sort each group according to its rules
  const sortedGroups = {
    globalPins: sortGlobalPins(groups.globalPins, globalPins),
    personalPins: sortPersonalPins(groups.personalPins, personalPins),
    regular: sortRegularTasks(groups.regular, sortConfig)
  };

  // 3. Concatenate in hierarchy order
  return [
    ...sortedGroups.globalPins,
    ...sortedGroups.personalPins,
    ...sortedGroups.regular
  ];
};
```

### Pin Type Categorization
```typescript
const categorizeTasksByPinType = (
  tasks: Task[],
  globalPins: GlobalPin[],
  personalPins: string[]
): SortedTaskGroups => {
  const globalPinMap = new Map(globalPins.map(pin => [pin.taskId, pin]));

  return tasks.reduce((groups, task) => {
    if (globalPinMap.has(task.taskID)) {
      groups.globalPins.push(task);
    } else if (personalPins.includes(task.taskID)) {
      groups.personalPins.push(task);
    } else {
      groups.regular.push(task);
    }
    return groups;
  }, { globalPins: [], personalPins: [], regular: [] });
};
```

### Global Pin Sorting Logic
```typescript
const sortGlobalPins = (tasks: Task[], globalPins: GlobalPin[]): Task[] => {
  const pinMap = new Map(globalPins.map(pin => [pin.taskId, pin]));

  return tasks.sort((a, b) => {
    const pinA = pinMap.get(a.taskID);
    const pinB = pinMap.get(b.taskID);

    // Sort by priority first (higher priority = lower number, appears first)
    if (pinA.priority !== pinB.priority) {
      return pinA.priority - pinB.priority;
    }

    // Then by pin date (most recent first)
    return new Date(pinB.pinnedAt).getTime() - new Date(pinA.pinnedAt).getTime();
  });
};
```

### Dashboard Integration Hook
```typescript
export const useTaskSortingWithPins = () => {
  const { globalPins, personalPins } = usePinStore();
  const { sortConfig } = useDashboardStore();

  const sortTasks = useCallback((tasks: Task[]) => {
    return sortTasksWithPinHierarchy(tasks, globalPins, personalPins, sortConfig);
  }, [globalPins, personalPins, sortConfig]);

  return { sortTasks };
};
```

### Kanban Integration
```typescript
const KanbanColumn: React.FC<{ status: TaskStatus; tasks: Task[] }> = ({
  status,
  tasks
}) => {
  const { sortTasks } = useTaskSortingWithPins();

  const sortedTasks = useMemo(() => {
    return sortTasks(tasks.filter(task => task.status === status));
  }, [tasks, status, sortTasks]);

  return (
    <div className="kanban-column">
      {sortedTasks.map(task => (
        <KanbanCard key={task.taskID} task={task} />
      ))}
    </div>
  );
};
```

### Performance Optimizations
- Memoization of sort results using task dependencies
- Debounced sort updates for rapid pin changes
- Virtual scrolling for large task lists
- Selective re-sorting on pin state changes

### Testing Standards
- Sort hierarchy correctness testing
- Performance testing with large datasets
- Edge case testing (no pins, all pinned, mixed states)
- Kanban integration testing
- Filter compatibility testing

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-20 | 1.0 | Initial story creation | Winston (Architect) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by QA Agent after implementation review*