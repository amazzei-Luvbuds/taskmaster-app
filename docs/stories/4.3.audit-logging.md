# Story 4.3: Audit Logging and Metadata

## Status
Draft

## Story
**As a** system administrator,
**I want** comprehensive audit logging for all pin operations,
**so that** pin activities are tracked for compliance and debugging purposes.

## Acceptance Criteria

1. All pin operations (create/update/delete) are logged with metadata
2. Audit logs include user ID, timestamp, action type, and context
3. Pin history shows who pinned/unpinned tasks and when
4. Audit log retention policy prevents unlimited growth
5. Search and filtering capabilities for audit logs
6. Export functionality for audit reports

## Tasks / Subtasks

- [ ] Audit Log Schema Design (AC: 1, 2)
  - [ ] Create audit_logs table with comprehensive fields
  - [ ] Define log entry structure and metadata
  - [ ] Implement log entry creation utilities
  - [ ] Add indexing for performance queries

- [ ] Pin Operation Logging (AC: 1, 2)
  - [ ] Integrate logging into all pin API endpoints
  - [ ] Log personal pin operations
  - [ ] Log global pin operations with extra metadata
  - [ ] Capture before/after states for updates

- [ ] Pin History Interface (AC: 3)
  - [ ] Create pin history component for task details
  - [ ] Show chronological pin events
  - [ ] Display user information and context
  - [ ] Support pagination for long histories

- [ ] Log Management System (AC: 4, 5)
  - [ ] Implement log retention policy
  - [ ] Create log cleanup/archival process
  - [ ] Add search and filtering interface
  - [ ] Support date range and user filtering

- [ ] Audit Reporting (AC: 6)
  - [ ] Create audit report generation
  - [ ] Support CSV/Excel export formats
  - [ ] Add report templates for common queries
  - [ ] Implement scheduled report generation

## Dev Notes

### Relevant Source Tree
- `database/audit_logs.sql` - Audit log schema
- `api/audit/` - Audit logging utilities
- `src/components/AuditLog.tsx` - Audit log viewing component
- `src/pages/AdminAuditPage.tsx` - Admin audit management
- `api/reports/audit.php` - Audit report generation

### Audit Log Schema
```sql
CREATE TABLE audit_logs (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  event_type VARCHAR(50) NOT NULL,
  entity_type VARCHAR(50) NOT NULL,
  entity_id VARCHAR(255) NOT NULL,
  user_id VARCHAR(255) NOT NULL,
  user_name VARCHAR(255) NOT NULL,
  action VARCHAR(50) NOT NULL,
  before_state JSON,
  after_state JSON,
  metadata JSON,
  ip_address VARCHAR(45),
  user_agent TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_entity (entity_type, entity_id),
  INDEX idx_user (user_id),
  INDEX idx_event_type (event_type),
  INDEX idx_created_at (created_at)
);
```

### Audit Log Entry Structure
```typescript
interface AuditLogEntry {
  id: string;
  eventType: 'pin_operation' | 'user_action' | 'system_event';
  entityType: 'task_pin' | 'global_pin' | 'personal_pin';
  entityId: string; // Task ID
  userId: string;
  userName: string;
  action: 'create' | 'update' | 'delete';
  beforeState?: any;
  afterState?: any;
  metadata: {
    pinType: PinType;
    priority?: number;
    reason?: string;
    source: string; // 'web', 'api', 'bulk'
  };
  ipAddress: string;
  userAgent: string;
  createdAt: Date;
}
```

### Logging Service Implementation
```typescript
class AuditLogger {
  static async logPinOperation(data: {
    action: 'create' | 'update' | 'delete';
    taskId: string;
    userId: string;
    pinType: PinType;
    beforeState?: any;
    afterState?: any;
    metadata?: any;
  }) {
    const logEntry: AuditLogEntry = {
      id: generateId(),
      eventType: 'pin_operation',
      entityType: data.pinType === PinType.GLOBAL ? 'global_pin' : 'personal_pin',
      entityId: data.taskId,
      userId: data.userId,
      userName: await getUserName(data.userId),
      action: data.action,
      beforeState: data.beforeState,
      afterState: data.afterState,
      metadata: {
        pinType: data.pinType,
        source: 'web',
        ...data.metadata
      },
      ipAddress: getClientIP(),
      userAgent: getUserAgent(),
      createdAt: new Date()
    };

    await this.saveLogEntry(logEntry);
  }

  private static async saveLogEntry(entry: AuditLogEntry) {
    // Save to database with error handling and retry logic
  }
}
```

### Pin History Component
```typescript
interface PinHistoryProps {
  taskId: string;
  maxEntries?: number;
}

export const PinHistory: React.FC<PinHistoryProps> = ({
  taskId,
  maxEntries = 10
}) => {
  const { data: history, isLoading } = useQuery(
    ['pin-history', taskId],
    () => fetchPinHistory(taskId)
  );

  return (
    <div className="pin-history">
      <h4>Pin History</h4>
      {history?.map(entry => (
        <div key={entry.id} className="history-entry">
          <div className="entry-header">
            <UserAvatar userId={entry.userId} />
            <span>{entry.userName}</span>
            <span className="action-badge">{entry.action}</span>
            <time>{formatDate(entry.createdAt)}</time>
          </div>
          <div className="entry-details">
            {entry.metadata.reason && (
              <p className="pin-reason">{entry.metadata.reason}</p>
            )}
            {entry.metadata.priority && (
              <Badge>Priority: {entry.metadata.priority}/10</Badge>
            )}
          </div>
        </div>
      ))}
    </div>
  );
};
```

### Audit Search Interface
```typescript
interface AuditSearchFilters {
  dateRange: [Date, Date];
  users: string[];
  actions: string[];
  entityTypes: string[];
  searchText: string;
}

export const AuditLogSearch: React.FC = () => {
  const [filters, setFilters] = useState<AuditSearchFilters>();
  const { data: logs, isLoading } = useQuery(
    ['audit-logs', filters],
    () => searchAuditLogs(filters)
  );

  return (
    <div className="audit-search">
      <div className="search-filters">
        <DateRangePicker onChange={updateDateRange} />
        <UserMultiSelect onChange={updateUsers} />
        <ActionFilter onChange={updateActions} />
        <SearchInput onChange={updateSearchText} />
      </div>
      <div className="search-results">
        <AuditLogTable logs={logs} />
        <ExportButton filters={filters} />
      </div>
    </div>
  );
};
```

### Log Retention Policy
```typescript
interface RetentionPolicy {
  defaultRetentionDays: number;
  highPriorityRetentionDays: number;
  archiveAfterDays: number;
  enableAutoCleanup: boolean;
}

class LogRetentionManager {
  static async enforceRetentionPolicy(policy: RetentionPolicy) {
    // Archive old logs
    await this.archiveLogs(policy.archiveAfterDays);

    // Delete expired logs
    await this.deleteExpiredLogs(policy.defaultRetentionDays);

    // Cleanup orphaned entries
    await this.cleanupOrphanedEntries();
  }
}
```

### Audit Report Generation
```typescript
interface AuditReportConfig {
  title: string;
  filters: AuditSearchFilters;
  format: 'csv' | 'excel' | 'pdf';
  includeMetadata: boolean;
}

export const generateAuditReport = async (config: AuditReportConfig) => {
  const logs = await searchAuditLogs(config.filters);

  switch (config.format) {
    case 'csv':
      return generateCSVReport(logs, config);
    case 'excel':
      return generateExcelReport(logs, config);
    case 'pdf':
      return generatePDFReport(logs, config);
  }
};
```

### Testing Standards
- Audit log creation testing for all pin operations
- Log retention policy testing
- Search and filtering functionality testing
- Export functionality testing
- Performance testing with large log datasets
- Data integrity and consistency testing

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-20 | 1.0 | Initial story creation | Winston (Architect) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by QA Agent after implementation review*